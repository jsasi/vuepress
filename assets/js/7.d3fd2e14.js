(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{208:function(e,t,i){"use strict";i.r(t);var r=i(0),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"理解widgets"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#理解widgets"}},[e._v("#")]),e._v(" 理解Widgets")]),e._v(" "),i("p",[e._v("Flutter Widget采用现代响应式框架构建，这和React/Vue相似，他们的核心思想都是用 widget 来构建你的 UI 界面。 当widget的状态发生变化时，widget会重新构建UI，Flutter会对比前后变化的不同， 以确定底层渲染树从一个状态转换到下一个状态所需的最小更改，这也类似于React/Vue中虚拟DOM的diff算法。")]),e._v(" "),i("p",[e._v("但是Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 "),i("code",[e._v("GestureDetector")]),e._v(" widget、用于APP主题数据传递的"),i("code",[e._v("Theme")]),e._v("等等，也可以认为是Flutter把万事万物都封装在Widget里，万事万物都是组件。")]),e._v(" "),i("h2",{attrs:{id:"widget和element"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#widget和element"}},[e._v("#")]),e._v(" Widget和Element")]),e._v(" "),i("p",[e._v("Widget并非真正渲染到屏幕的ui元素，屏幕上显示的是Element，Widget包含了ui元素的配置，类似于包含dom元素和css、js的综合体。")]),e._v(" "),i("p",[e._v("Element是由Widget生成的，一个Widget可以对应多个Element。")]),e._v(" "),i("h2",{attrs:{id:"widget类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#widget类"}},[e._v("#")]),e._v(" Widget类")]),e._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("abstract class Widget extends DiagnosticableTree {\n  /// Initializes [key] for subclasses.\n  const Widget({ this.key });\n\n  final Key key;\n\n  @protected\n  Element createElement();\n\n  /// A short, textual description of this widget.\n  @override\n  String toStringShort() {\n    return key == null ? '$runtimeType' : '$runtimeType-$key';\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;\n  }\n\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n}\n")])]),e._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[e._v("1")]),i("br"),i("span",{staticClass:"line-number"},[e._v("2")]),i("br"),i("span",{staticClass:"line-number"},[e._v("3")]),i("br"),i("span",{staticClass:"line-number"},[e._v("4")]),i("br"),i("span",{staticClass:"line-number"},[e._v("5")]),i("br"),i("span",{staticClass:"line-number"},[e._v("6")]),i("br"),i("span",{staticClass:"line-number"},[e._v("7")]),i("br"),i("span",{staticClass:"line-number"},[e._v("8")]),i("br"),i("span",{staticClass:"line-number"},[e._v("9")]),i("br"),i("span",{staticClass:"line-number"},[e._v("10")]),i("br"),i("span",{staticClass:"line-number"},[e._v("11")]),i("br"),i("span",{staticClass:"line-number"},[e._v("12")]),i("br"),i("span",{staticClass:"line-number"},[e._v("13")]),i("br"),i("span",{staticClass:"line-number"},[e._v("14")]),i("br"),i("span",{staticClass:"line-number"},[e._v("15")]),i("br"),i("span",{staticClass:"line-number"},[e._v("16")]),i("br"),i("span",{staticClass:"line-number"},[e._v("17")]),i("br"),i("span",{staticClass:"line-number"},[e._v("18")]),i("br"),i("span",{staticClass:"line-number"},[e._v("19")]),i("br"),i("span",{staticClass:"line-number"},[e._v("20")]),i("br"),i("span",{staticClass:"line-number"},[e._v("21")]),i("br"),i("span",{staticClass:"line-number"},[e._v("22")]),i("br"),i("span",{staticClass:"line-number"},[e._v("23")]),i("br"),i("span",{staticClass:"line-number"},[e._v("24")]),i("br"),i("span",{staticClass:"line-number"},[e._v("25")]),i("br"),i("span",{staticClass:"line-number"},[e._v("26")]),i("br")])]),i("ul",[i("li",[i("p",[i("code",[e._v("Widget")]),e._v("类继承自"),i("code",[e._v("DiagnosticableTree")]),e._v("，"),i("code",[e._v("DiagnosticableTree")]),e._v("即“诊断树”，主要作用是提供调试信息。")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("Key")]),e._v(": 这个"),i("code",[e._v("key")]),e._v("属性类似于React/Vue中的"),i("code",[e._v("key")]),e._v("，主要的作用是决定是否在下一次"),i("code",[e._v("build")]),e._v("时复用旧的widget，决定的条件在"),i("code",[e._v("canUpdate()")]),e._v("方法中。")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("createElement()")]),e._v("：正如前文所述“一个Widget可以对应多个"),i("code",[e._v("Element")]),e._v("”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的"),i("code",[e._v("Element")]),e._v("对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("debugFillProperties(...)")]),e._v(" 复写父类的方法，主要是设置诊断树的一些特性。")])]),e._v(" "),i("li",[i("p",[i("code",[e._v("canUpdate(...)")]),e._v("是一个静态方法，它主要用于在Widget树重新"),i("code",[e._v("build")]),e._v("时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的"),i("code",[e._v("Element")]),e._v("对象的配置；通过其源码我们可以看到，只要"),i("code",[e._v("newWidget")]),e._v("与"),i("code",[e._v("oldWidget")]),e._v("的"),i("code",[e._v("runtimeType")]),e._v("和"),i("code",[e._v("key")]),e._v("同时相等时就会用"),i("code",[e._v("newWidget")]),e._v("去更新"),i("code",[e._v("Element")]),e._v("对象的配置，否则就会创建新的"),i("code",[e._v("Element")]),e._v("。")]),e._v(" "),i("h2",{attrs:{id:"statelesswidget"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#statelesswidget"}},[e._v("#")]),e._v(" StatelessWidget")]),e._v(" "),i("p",[e._v("一般的我们实现新组件，并不直接继承Widget，而是继承StatelessWidget或者StatefulWidget，StatelessWidget是无状态的静态组件，Flutter会递归调用所有的Widget。一般地，在写Widget的时候，我们会先写"),i("code",[e._v("key")]),e._v("参数，"),i("code",[e._v("child")]),e._v("和"),i("code",[e._v("children")]),e._v("是最后写的。")]),e._v(" "),i("p",[e._v("既然是递归调用，我们在子组件里，可以通过"),i("code",[e._v("context.ancestorWidgetOfExactType()")]),e._v("获取子组件的最近父级组件。")]),e._v(" "),i("h2",{attrs:{id:"statefulwidget"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#statefulwidget"}},[e._v("#")]),e._v(" StatefulWidget")]),e._v(" "),i("p",[e._v("如果需要变更状态，比如点击变色、单选框、进度条等，需要继承StatefulWidget，重写"),i("code",[e._v("createState（）")]),e._v(",返回一个State。")]),e._v(" "),i("h3",{attrs:{id:"state"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[e._v("#")]),e._v(" State")]),e._v(" "),i("p",[e._v("一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态。当State被改变时，可以手动调用其"),i("code",[e._v("setState()")]),e._v("方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其"),i("code",[e._v("build")]),e._v("方法重新构建widget树，从而达到更新UI的目的。")]),e._v(" "),i("p",[e._v("State的"),i("code",[e._v("build(BuildContext context)")]),e._v("方法返回WIdget,为什么不放在StatefulWidget里呢：")]),e._v(" "),i("ul",[i("li",[i("p",[e._v("状态访问不便 。")]),e._v(" "),i("p",[e._v("State包含组件的状态，而组件会根据状态改变，所以分开的话获取状态不方便。")])]),e._v(" "),i("li",[i("p",[e._v("继承StatefulWidget不便。")]),e._v(" "),i("p",[e._v("有的组件本身有build方法。")])])])])]),e._v(" "),i("h4",{attrs:{id:"state生命周期"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#state生命周期"}},[e._v("#")]),e._v(" State生命周期")]),e._v(" "),i("p",[i("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action/docs/imgs/3-2.jpg",alt:"声明周期"}})]),e._v(" "),i("ul",[i("li",[i("code",[e._v("initState")]),e._v("：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用"),i("code",[e._v("BuildContext.inheritFromWidgetOfExactType")]),e._v("（该方法用于在Widget树上获取离当前widget最近的一个父级"),i("code",[e._v("InheritFromWidget")]),e._v("，关于"),i("code",[e._v("InheritedWidget")]),e._v("我们将在后面章节介绍），原因是在初始化完成后，Widget树中的"),i("code",[e._v("InheritFromWidget")]),e._v("也可能会发生变化，所以正确的做法应该在在"),i("code",[e._v("build（）")]),e._v("方法或"),i("code",[e._v("didChangeDependencies()")]),e._v("中调用它。")]),e._v(" "),i("li",[i("code",[e._v("didChangeDependencies()")]),e._v("：当State对象的依赖发生变化时会被调用；例如：在之前"),i("code",[e._v("build()")]),e._v(" 中包含了一个"),i("code",[e._v("InheritedWidget")]),e._v("，然后在之后的"),i("code",[e._v("build()")]),e._v(" 中"),i("code",[e._v("InheritedWidget")]),e._v("发生了变化，那么此时"),i("code",[e._v("InheritedWidget")]),e._v("的子widget的"),i("code",[e._v("didChangeDependencies()")]),e._v("回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。")]),e._v(" "),i("li",[i("code",[e._v("build()")]),e._v("：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用：\n"),i("ol",[i("li",[e._v("在调用"),i("code",[e._v("initState()")]),e._v("之后。")]),e._v(" "),i("li",[e._v("在调用"),i("code",[e._v("didUpdateWidget()")]),e._v("之后。")]),e._v(" "),i("li",[e._v("在调用"),i("code",[e._v("setState()")]),e._v("之后。")]),e._v(" "),i("li",[e._v("在调用"),i("code",[e._v("didChangeDependencies()")]),e._v("之后。")]),e._v(" "),i("li",[e._v("在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。")])])]),e._v(" "),i("li",[i("code",[e._v("reassemble()")]),e._v("：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。")]),e._v(" "),i("li",[i("code",[e._v("didUpdateWidget()")]),e._v("：在widget重新构建时，Flutter framework会调用"),i("code",[e._v("Widget.canUpdate")]),e._v("来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果"),i("code",[e._v("Widget.canUpdate")]),e._v("返回"),i("code",[e._v("true")]),e._v("则会调用此回调。正如之前所述，"),i("code",[e._v("Widget.canUpdate")]),e._v("会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时"),i("code",[e._v("didUpdateWidget()")]),e._v("就会被调用。")]),e._v(" "),i("li",[i("code",[e._v("deactivate()")]),e._v("：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用"),i("code",[e._v("dispose()")]),e._v("方法。")]),e._v(" "),i("li",[i("code",[e._v("dispose()")]),e._v("：当State对象从树中被永久移除时调用；通常在此回调中释放资源。")])]),e._v(" "),i("h2",{attrs:{id:"布局类组件"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#布局类组件"}},[e._v("#")]),e._v(" 布局类组件")]),e._v(" "),i("p",[e._v("Flutter拥有丰富的布局widget，但这里有一些最常用的布局widget。其目的是尽可能快地让您构建应用并运行，而不是让您淹没在整个完整的widget列表中。 有关其他可用widget的信息，请参阅"),i("a",{attrs:{href:"https://flutter.io/widgets/",target:"_blank",rel:"noopener noreferrer"}},[e._v("widget概述"),i("OutboundLink")],1),e._v("，或使用"),i("a",{attrs:{href:"https://docs.flutter.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("API 参考 docs"),i("OutboundLink")],1),e._v("文档中的搜索框。 此外，API文档中的widget页面经常会推荐一些可能更适合您需求的类似widget。")]),e._v(" "),i("p",[e._v("以下widget分为两类："),i("a",{attrs:{href:"https://docs.flutter.io/flutter/widgets/widgets-library.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("widgets library"),i("OutboundLink")],1),e._v("中的标准widget和"),i("a",{attrs:{href:"https://docs.flutter.io/flutter/material/material-library.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Material Components library"),i("OutboundLink")],1),e._v("中的专用widget 。 任何应用程序都可以使用widgets library中的widget，但只有Material应用程序可以使用Material Components库。")]),e._v(" "),i("h3",{attrs:{id:"标准-widgets"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#标准-widgets"}},[e._v("#")]),e._v(" 标准 widgets")]),e._v(" "),i("ul",[i("li",[i("p",[i("a",{attrs:{href:"https://flutterchina.club/tutorials/layout/#container",target:"_blank",rel:"noopener noreferrer"}},[e._v("Container"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("添加 padding, margins, borders, background color, 或将其他装饰添加到widget.")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"https://flutterchina.club/tutorials/layout/#gridview",target:"_blank",rel:"noopener noreferrer"}},[e._v("GridView"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("将 widgets 排列为可滚动的网格.")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"https://flutterchina.club/tutorials/layout/#listview",target:"_blank",rel:"noopener noreferrer"}},[e._v("ListView"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("将widget排列为可滚动列表")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"https://flutterchina.club/tutorials/layout/#stack",target:"_blank",rel:"noopener noreferrer"}},[e._v("Stack"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("将widget重叠在另一个widget之上.")])])]),e._v(" "),i("h3",{attrs:{id:"material-components"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#material-components"}},[e._v("#")]),e._v(" Material Components")]),e._v(" "),i("ul",[i("li",[i("p",[i("a",{attrs:{href:"https://flutterchina.club/tutorials/layout/#card",target:"_blank",rel:"noopener noreferrer"}},[e._v("Card"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("将相关内容放到带圆角和投影的盒子中。")])]),e._v(" "),i("li",[i("p",[i("a",{attrs:{href:"https://flutterchina.club/tutorials/layout/#listtile",target:"_blank",rel:"noopener noreferrer"}},[e._v("ListTile"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("将最多3行文字，以及可选的行前和和行尾的图标排成一行")])])]),e._v(" "),i("p",[i("strong",[e._v("配置文件 Widget 生成了 Element，而后创建 RenderObject 关联到 Element 的内部 "),i("code",[e._v("renderObject")]),e._v(" 对象上，最后Flutter 通过 RenderObject 数据来布局和绘制。")]),e._v(" 理论上你也可以认为 RenderObject 是最终给 Flutter 的渲染数据，它保存了大小和位置等信息，Flutter 通过它去绘制出画面。RenderObject 涉及到布局、计算、绘制等流程，要是每次都全部重新创建开销就比较大了。所以Widget 做了对应的判断以便于复用，比如：在 "),i("code",[e._v("newWidget")]),e._v(" 与"),i("code",[e._v("oldWidget")]),e._v(" 的 "),i("em",[e._v("runtimeType")]),e._v(" 和 "),i("em",[e._v("key")]),e._v(" 相等时会选择使用 "),i("code",[e._v("newWidget")]),e._v(" 去更新已经存在的 Element 对象，不然就选择重新创建新的 Element。")]),e._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v(" static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n")])]),e._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[e._v("1")]),i("br"),i("span",{staticClass:"line-number"},[e._v("2")]),i("br"),i("span",{staticClass:"line-number"},[e._v("3")]),i("br"),i("span",{staticClass:"line-number"},[e._v("4")]),i("br")])]),i("p",[i("strong",[e._v("Widget 重新创建，Element 树和 RenderObject 树并不会完全重新创建。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);